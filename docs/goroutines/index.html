<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Demystifying Goroutines - Channels, WaitGroup, Cancellation | Shizra Tariq</title>
<meta name="keywords" content="golang, goroutine, go channel">
<meta name="description" content="If you have rough ideas on how goroutines work but never took the time to learn the idiomatic approach and why we want to run goroutines certain way, this blog will be of help. In this post, I will be summarizing what I have learned from Chapter 8: Goroutines and Channels of the Go Programming Language book as well as The Go Blog on Go Concurrency Patterns.
This blog post will be helpful if you are not familiar with any of the below:">
<meta name="author" content="Shizra Tariq">
<link rel="canonical" href="https://shizratariq.github.io/docs/goroutines/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.319c3c1fd58ba2da1d33ada5234cc7970adf6d05d595ba115d5f87db16905004.css" integrity="sha256-MZw8H9WLotodM62lI0zHlwrfbQXVlboRXV&#43;H2xaQUAQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://shizratariq.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://shizratariq.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://shizratariq.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://shizratariq.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://shizratariq.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Demystifying Goroutines - Channels, WaitGroup, Cancellation" />
<meta property="og:description" content="If you have rough ideas on how goroutines work but never took the time to learn the idiomatic approach and why we want to run goroutines certain way, this blog will be of help. In this post, I will be summarizing what I have learned from Chapter 8: Goroutines and Channels of the Go Programming Language book as well as The Go Blog on Go Concurrency Patterns.
This blog post will be helpful if you are not familiar with any of the below:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://shizratariq.github.io/docs/goroutines/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2023-09-09T13:51:42-04:00" />
<meta property="article:modified_time" content="2023-09-09T13:51:42-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Demystifying Goroutines - Channels, WaitGroup, Cancellation"/>
<meta name="twitter:description" content="If you have rough ideas on how goroutines work but never took the time to learn the idiomatic approach and why we want to run goroutines certain way, this blog will be of help. In this post, I will be summarizing what I have learned from Chapter 8: Goroutines and Channels of the Go Programming Language book as well as The Go Blog on Go Concurrency Patterns.
This blog post will be helpful if you are not familiar with any of the below:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://shizratariq.github.io/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Demystifying Goroutines - Channels, WaitGroup, Cancellation",
      "item": "https://shizratariq.github.io/docs/goroutines/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Demystifying Goroutines - Channels, WaitGroup, Cancellation",
  "name": "Demystifying Goroutines - Channels, WaitGroup, Cancellation",
  "description": "If you have rough ideas on how goroutines work but never took the time to learn the idiomatic approach and why we want to run goroutines certain way, this blog will be of help. In this post, I will be summarizing what I have learned from Chapter 8: Goroutines and Channels of the Go Programming Language book as well as The Go Blog on Go Concurrency Patterns.\nThis blog post will be helpful if you are not familiar with any of the below:",
  "keywords": [
    "golang", "goroutine", "go channel"
  ],
  "articleBody": "If you have rough ideas on how goroutines work but never took the time to learn the idiomatic approach and why we want to run goroutines certain way, this blog will be of help. In this post, I will be summarizing what I have learned from Chapter 8: Goroutines and Channels of the Go Programming Language book as well as The Go Blog on Go Concurrency Patterns.\nThis blog post will be helpful if you are not familiar with any of the below:\nHow to wait for the other goroutines to finish instead of exiting on the main goroutine Unbuffered vs. buffered channels and the pros \u0026 cons of each Running loops in parallel (goroutines inside the loop) Unbounded parallelism \u0026 semaphores Multiplexing with select \u0026 goroutine cancellation We will also answer some of the questions such as:\nWhat is a goroutine leak and how do we prevent it? Do we need to close all the channels and goroutines? Why do we want to have our waitGroup in its own goroutine? You should already know that a goroutine is an activity of a concurrent Go program and channel is a communicating mechanism between the goroutines. We all wish running a concurrent program is as simple as prepending go to a method. However, there is often a little more we need to make goroutines work as intended. Let’s have a look at different use cases starting from the first bullet point on the list above.\nHow to wait for other goroutines to finish instead of exiting on the main goroutine func main() { // ... done := make(chan struct{}) go func() { // ... done \u003c- struct{}{} // signal the main goroutine }() // ... \u003c- done // wait for background goroutine to finish } In the code snippet above, we define an unbuffered channel called done. The channel is unbuffered because we are not assigning any capacity/size to the channel. We will take a look at buffered channels in another example later. The main characteristic of an unbuffered channel is that it blocks until another goroutine executes a corresponding receive on the same channel, causing the sending and receiving goroutines to be “synchronous”. With the unbuffered channel in the example above, we can ensure that the program waits for the background goroutine to finish before exiting. You can find the code example from the book here.\nUnbuffered vs. buffered channels Let’s have a look at an example from the book where an unbuffered channel might lead to a problem.\nfunc mirroredQuery() string { responses := make(chan string) go func() { responses \u003c- \"response 1\" }() go func() { responses \u003c- \"response 2\" }() go func() { responses \u003c- \"response 3\" }() return \u003c-responses // return the quickest response } With unbuffered channels, there might be a scenario like the above where the two slower goroutines (as to which of the three would be the fastest is non-deterministic) would be stuck trying to send their responses on a channel from which no goroutine will ever receive. This is known as a goroutine leak and it is important to ensure that the goroutines terminate themselves when no longer needed since leaked goroutines are not automatically collected.\nHowever, we would not encounter a goroutine leak if we use a buffered channel instead as such: responses := make(chan string, 3) where we assign a capacity of 3 to the channel. That buffered channel would hold up to three string values and block until a space is made available by another goroutine’s receive. And even if the sending channel closes, the values queued up in the channel can be handled later by the receiving channels.\nAlthough unbuffered channels provide stronger synchronization guarantees, it would require prudence on our end to avoid goroutine leaks. If the synchronization does not matter as much and you know the upper bound on the number of values that will be sent on the channel, a buffered channel could be a better option. However, it is worth noting that failure to allocate sufficient buffer capacity would cause the program to deadlock.\nAs we looked at an example of a goroutine leak, you might have also wondered if we have to close all the channels as well. The answer is that you do not need to close every channel unless it is important to tell the receiving goroutines that all data have been sent. Channels that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. However, closing an already-closed channel causes a panic, as does closing a nil channel.\nRunning loops in parallel At first glance, looping in parallel might appear to be as simple as:\nfunc parallelLoop() { for _, f := range filenames { go func(f string) { // ... }(f) } } However, when you run the function above, you will observe that the function exits almost immediately. The above doesn’t work because parallelLoop() returns before it has finished all its work. We have to change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel as below:\nfunc parallelLoop() { ch := make(chan struct{}) for _, f := range filenames { go func(f string) { // ... ch \u003c- struct{}{} }(f) } for range filenames { \u003c-ch } } One other thing worth highlighting is that the f is passed into the goroutine as an explicit argument as such: go func(f string){...}(f) and not directly used in the goroutine. Explicit parameters are used for goroutines in a loop to ensure that we use the value of f that is current when the go statement is executed.\nHowever, the above example does not take error handling into consideration. Now let’s have a look at the idiomatic approach to looping in parallel using the sync.WaitGroup and handling errors appropriately:\nfunc makeThumbnails(filesnames \u003c-chan string) int64 { sizes := make(chan int64) var wg sync.WaitGroup for f := range filenames { wg.Add(1) go func(f string) { defer wg.Done() // run operations to retrieve the size of the file sizes \u003c- size }(f) } // closer go func() { wg.Wait() close(sizes) } var total int64 for size := range sizes { total += size } return total } Above is a snippet of code where we retrieve the size of different files in parallel and compute the total size. The example used in the book can be found here. There are a few things we want to pay attention from the above:\nwg.Add(1) must be called before the worker goroutine starts, not within it—this ensures that the Add happens before the closer goroutine calls Wait defer is used on wg.Done() to ensure that Done is called even in the error cases The closer goroutine that waits for the workers must be created before the closing of the sizes channel The closer goroutine must be concurrent with the loop over sizes If the wait operation was placed before the loop in the main goroutine: it would never end If the wait operation was placed after the loop in the main goroutine: the loop would never terminate because there is nothing closing the sizes channel and the wait operation will be unreachable Unbounded parallelism If there is a limiting factor in the system, such as the number of CPU cores, the number of spindles and heads for local disk I/O operations, or the bandwidth of the network, we want to limit the number of parallel uses of the resource to match the level of parallelism that is available.\nWe can limit parallelism using a buffered channel of capacity n to model a concurrency primitive called a counting semaphore. Conceptually sending a value into the channel acquires a token and receiving a value from the channel releases the token, ensuring that at most n sends can occur without an intervening receive. Let’s have a look at an example:\nvar tokens = make(chan struct{}, 20) func doSomething() { tokens \u003c- struct{}{} // acquire the token // .. \u003c-tokens // release the token } Alternatively, you can use the golang semaphore package and call Acquire and Release on the semaphore that is equivalent of the token concept above.\nvar sem = semaphore.NewWeighted(int64(10)) sem.Acquire(ctx, 1) // equivalent to sem \u003c- 1 (using channel approach) sem.Release(1) // equivalent to \u003c- sem (using channel approach) There is a blog post that covers semaphore in greater detail here.\nMultiplexing with select \u0026 cancellation The select statement comes in handy when we need to wait for an event on one of the many channels. The select statement can be used with a ticker to run a loop every n seconds/minutes/hours as below:\nticker := time.NewTicker(5 * time.Second) go func() { for ... { // some operations select { case \u003c- ticker.C: case \u003c- done: return default: } } } Notice how we have a case for a receive operation on a done channel. That is useful when want the main goroutine to tell the other goroutines (above goroutine in this case) to abandon the values they are trying to send. Otherwise those goroutines with work left will be stuck trying to send their responses on a channel from which no goroutine will ever receive, leading to resource leak as mentioned earlier. In order for that to work, we will need to close the done channel at the end of the main() as done below:\nfunc main() { // Set up a done channel that's shared by the whole pipeline, // and close that channel when this pipeline exits, as a signal // for all the goroutines we started to exit done := make(chan struct{}) defer close(done) // some operations go func(done \u003c-chan struct{}){ ... }(done) // done will be closed by the deferred call } Here are a few other details about the multiplexing with the select statement that you might find useful:\nIf multiple cases are ready, select picks one at a random. If there is a case in the select statement where the channel can optionally be nil (depending on the flag passed in), the case is effectively disabled I hope this post has provided some context for you to get started with concurrency in Go. If you would like to learn more about them, make sure you check out Chapter 8: Goroutines and Channels of the Go Programming Language book as well as The Go Blog on Go Concurrency Patterns.\n",
  "wordCount" : "1737",
  "inLanguage": "en",
  "datePublished": "2023-09-09T13:51:42-04:00",
  "dateModified": "2023-09-09T13:51:42-04:00",
  "author":{
    "@type": "Person",
    "name": "Shizra Tariq"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shizratariq.github.io/docs/goroutines/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Shizra Tariq",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shizratariq.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://shizratariq.github.io/" accesskey="h" title="Shizra Tariq (Alt + H)">Shizra Tariq</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://shizratariq.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://shizratariq.github.io/experience/" title="Experience">
                    <span>Experience</span>
                </a>
            </li>
            <li>
                <a href="https://shizratariq.github.io/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://shizratariq.github.io/skills/" title="Skills">
                    <span>Skills</span>
                </a>
            </li>
            <li>
                <a href="https://shizratariq.github.io/awards/" title="Awards">
                    <span>Awards</span>
                </a>
            </li>
            <li>
                <a href="https://shizratariq.github.io/extracurricular/" title="Extracurricular">
                    <span>Extracurricular</span>
                </a>
            </li>
            <li>
                <a href="https://shizratariq.github.io/cv/" title="CV">
                    <span>CV</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://shizratariq.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://shizratariq.github.io/docs/">Docs</a></div>
    <h1 class="post-title">
      Demystifying Goroutines - Channels, WaitGroup, Cancellation
    </h1>
    <div class="post-meta"><span title='2023-09-09 13:51:42 -0400 -0400'>September 9, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Shizra Tariq

</div>
  </header> 
  <div class="post-content"><p>If you have rough ideas on how goroutines work but never took the time to learn the idiomatic approach and why we want to run goroutines certain way, this blog will be of help. In this post, I will be summarizing what I have learned from <code>Chapter 8: Goroutines and Channels</code> of the <a href="https://amzn.to/45LKKfM">Go Programming Language</a> book as well as <a href="https://go.dev/blog/pipelines">The Go Blog on Go Concurrency Patterns</a>.</p>
<p>This blog post will be helpful if you are not familiar with any of the below:</p>
<ul>
<li>How to wait for the other goroutines to finish instead of exiting on the main goroutine</li>
<li>Unbuffered vs. buffered channels and the pros &amp; cons of each</li>
<li>Running loops in parallel (goroutines inside the loop)</li>
<li>Unbounded parallelism &amp; semaphores</li>
<li>Multiplexing with <code>select</code> &amp; goroutine cancellation</li>
</ul>
<p>We will also answer some of the questions such as:</p>
<ul>
<li>What is a goroutine leak and how do we prevent it?</li>
<li>Do we need to close all the channels and goroutines?</li>
<li>Why do we want to have our waitGroup in its own goroutine?</li>
</ul>
<p>You should already know that a goroutine is an activity of a concurrent Go program and channel is a communicating mechanism between the goroutines. We all wish running a concurrent program is as simple as prepending <code>go</code> to a method. However, there is often a little more we need to make goroutines work as intended. Let&rsquo;s have a look at different use cases starting from the first bullet point on the list above.</p>
<h3 id="how-to-wait-for-other-goroutines-to-finish-instead-of-exiting-on-the-main-goroutine">How to wait for other goroutines to finish instead of exiting on the main goroutine<a hidden class="anchor" aria-hidden="true" href="#how-to-wait-for-other-goroutines-to-finish-instead-of-exiting-on-the-main-goroutine">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">struct</span>{}{} <span style="color:#75715e">// signal the main goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">done</span> <span style="color:#75715e">// wait for background goroutine to finish 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In the code snippet above, we define an unbuffered channel called <code>done</code>. The channel is unbuffered because we are not assigning any capacity/size to the channel. We will take a look at buffered channels in another example later. The main characteristic of an unbuffered channel is that it blocks until another goroutine executes a corresponding receive on the same channel, causing the sending and receiving goroutines to be &ldquo;synchronous&rdquo;. With the unbuffered channel in the example above, we can ensure that the program waits for the background goroutine to finish before exiting. You can find the code example from the book <a href="https://github.com/adonovan/gopl.io/blob/master/ch8/netcat3/netcat.go#L17-L31">here</a>.</p>
<h3 id="unbuffered-vs-buffered-channels">Unbuffered vs. buffered channels<a hidden class="anchor" aria-hidden="true" href="#unbuffered-vs-buffered-channels">#</a></h3>
<p>Let&rsquo;s have a look at an example from the book where an unbuffered channel might lead to a problem.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mirroredQuery</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">responses</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">responses</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;response 1&#34;</span> }()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">responses</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;response 2&#34;</span> }()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">responses</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;response 3&#34;</span> }()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">responses</span> <span style="color:#75715e">// return the quickest response
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>With unbuffered channels, there might be a scenario like the above where the two slower goroutines (as to which of the three would be the fastest is non-deterministic) would be stuck trying to send their responses on a channel from which no goroutine will ever receive. This is known as a <code>goroutine leak</code> and it is important to ensure that the goroutines terminate themselves when no longer needed since leaked goroutines are not automatically collected.</p>
<p>However, we would not encounter a <code>goroutine leak</code> if we use a buffered channel instead as such: <code>responses := make(chan string, 3)</code> where we assign a capacity of 3 to the channel. That buffered channel would hold up to three string values and block until a space is made available by another goroutine&rsquo;s receive. And even if the sending channel closes, the values queued up in the channel can be handled later by the receiving channels.</p>
<p>Although unbuffered channels provide stronger synchronization guarantees, it would require prudence on our end to avoid goroutine leaks. If the synchronization does not matter as much and you know the upper bound on the number of values that will be sent on the channel, a buffered channel could be a better option. However, it is worth noting that failure to allocate sufficient buffer capacity would cause the program to deadlock.</p>
<p>As we looked at an example of a goroutine leak, you might have also wondered if we have to close all the channels as well. The answer is that you do not need to close every channel unless it is important to tell the receiving goroutines that all data have been sent. Channels that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. However, closing an already-closed channel causes a panic, as does closing a nil channel.</p>
<h3 id="running-loops-in-parallel">Running loops in parallel<a hidden class="anchor" aria-hidden="true" href="#running-loops-in-parallel">#</a></h3>
<p>At first glance, looping in parallel might appear to be as simple as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parallelLoop</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">filenames</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}(<span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, when you run the function above, you will observe that the function exits almost immediately. The above doesn’t work because <code>parallelLoop()</code> returns before it has finished all its work. We have to change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel as below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parallelLoop</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">filenames</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">filenames</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>One other thing worth highlighting is that the <code>f</code> is passed into the goroutine as an explicit argument as such: <code>go func(f string){...}(f)</code> and not directly used in the goroutine. Explicit parameters are used for goroutines in a loop to ensure that we use the value of <code>f</code> that is current when the go statement is executed.</p>
<p>However, the above example does not take error handling into consideration. Now let’s have a look at the idiomatic approach to looping in parallel using the <code>sync.WaitGroup</code> and handling errors appropriately:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeThumbnails</span>(<span style="color:#a6e22e">filesnames</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sizes</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int64</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">filenames</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// run operations to retrieve the size of the file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">sizes</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">size</span>
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// closer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>		close(<span style="color:#a6e22e">sizes</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">total</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sizes</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">size</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">total</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Above is a snippet of code where we retrieve the size of different files in parallel and compute the total size. The example used in the book can be found <a href="https://github.com/adonovan/gopl.io/blob/master/ch8/thumbnail/thumbnail_test.go#L117-L146">here</a>. There are a few things we want to pay attention from the above:</p>
<ol>
<li><code>wg.Add(1)</code> must be called before the worker goroutine starts, not within it—this ensures that the <code>Add</code> happens before the closer goroutine calls <code>Wait</code></li>
<li>defer is used on <code>wg.Done()</code> to ensure that Done is called even in the error cases</li>
<li>The closer goroutine that waits for the workers must be created before the closing of the sizes channel</li>
<li>The closer goroutine must be concurrent with the loop over sizes
<ul>
<li>If the wait operation was placed before the loop in the main goroutine: it would never end</li>
<li>If the wait operation was placed after the loop in the main goroutine: the loop would never terminate because there is nothing closing the <code>sizes</code> channel and the wait operation will be unreachable</li>
</ul>
</li>
</ol>
<h3 id="unbounded-parallelism">Unbounded parallelism<a hidden class="anchor" aria-hidden="true" href="#unbounded-parallelism">#</a></h3>
<p>If there is a limiting factor in the system, such as the number of CPU cores, the number of spindles and heads for local disk I/O operations, or the bandwidth of the network, we want to limit the number of parallel uses of the resource to match the level of parallelism that is available.</p>
<p>We can limit parallelism using a buffered channel of capacity <code>n</code> to model a concurrency primitive called a <code>counting semaphore</code>. Conceptually sending a value into the channel acquires a token and receiving a value from the channel releases the token, ensuring that at most n sends can occur without an intervening receive. Let&rsquo;s have a look at an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">tokens</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}, <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSomething</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tokens</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">struct</span>{}{} <span style="color:#75715e">// acquire the token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// ..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tokens</span> <span style="color:#75715e">// release the token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Alternatively, you can use the golang <a href="https://pkg.go.dev/golang.org/x/sync/semaphore">semaphore package</a> and call <code>Acquire</code> and <code>Release</code> on the semaphore that is equivalent of the token concept above.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sem</span> = <span style="color:#a6e22e">semaphore</span>.<span style="color:#a6e22e">NewWeighted</span>(int64(<span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sem</span>.<span style="color:#a6e22e">Acquire</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// equivalent to sem &lt;- 1 (using channel approach)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">sem</span>.<span style="color:#a6e22e">Release</span>(<span style="color:#ae81ff">1</span>) <span style="color:#75715e">// equivalent to &lt;- sem (using channel approach)
</span></span></span></code></pre></div><p>There is a blog post that covers semaphore in greater detail <a href="https://medium.com/@deckarep/gos-extended-concurrency-semaphores-part-1-5eeabfa351ce">here</a>.</p>
<h3 id="multiplexing-with-select--cancellation">Multiplexing with select &amp; cancellation<a hidden class="anchor" aria-hidden="true" href="#multiplexing-with-select--cancellation">#</a></h3>
<p>The select statement comes in handy when we need to wait for an event on one of the many channels. The select statement can be used with a ticker to run a loop every n seconds/minutes/hours as below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#a6e22e">ticker</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTicker</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#f92672">...</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// some operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">C</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">done</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice how we have a case for a receive operation on a <code>done</code> channel. That is useful when want the main goroutine to tell the other goroutines (above goroutine in this case) to abandon the values they are trying to send. Otherwise those goroutines with work left will be stuck trying to send their responses on a channel from which no goroutine will ever receive, leading to resource leak as mentioned earlier. In order for that to work, we will need to close the done channel at the end of the <code>main()</code> as done below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Set up a done channel that&#39;s shared by the whole pipeline,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// and close that channel when this pipeline exits, as a signal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// for all the goroutines we started to exit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">done</span>)          
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// some operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}){
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">done</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// done will be closed by the deferred call
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Here are a few other details about the multiplexing with the <code>select</code> statement that you might find useful:</p>
<ul>
<li>If multiple cases are ready, <code>select</code> picks one at a random.</li>
<li>If there is a case in the select statement where the channel can optionally be nil (depending on the flag passed in), the case is effectively disabled</li>
</ul>
<p>I hope this post has provided some context for you to get started with concurrency in Go. If you would like to learn more about them, make sure you check out <code>Chapter 8: Goroutines and Channels</code> of the <a href="https://amzn.to/45LKKfM">Go Programming Language</a> book as well as <a href="https://go.dev/blog/pipelines">The Go Blog on Go Concurrency Patterns</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://shizratariq.github.io/tags/golang/">golang</a></li>
      <li><a href="https://shizratariq.github.io/tags/goroutine/">goroutine</a></li>
      <li><a href="https://shizratariq.github.io/tags/go-channel/">go channel</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://shizratariq.github.io/docs/deploy-hugo-to-github-pages/">
    <span class="title">Next »</span>
    <br>
    <span>Deploying a Blog Powered by Hugo to Github Pages w/ Custom Domain via Github Actions</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://shizratariq.github.io/">Shizra Tariq</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
